<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mouse Follower Dot</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            height: 100vh;
            cursor: none;
            font-family: system-ui, -apple-system, sans-serif;
        }
        
        .dot {
            position: absolute;
            pointer-events: none;
            transform: translate(-50%, -50%);
            background-color: transparent;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            border: none;
        }
        
        .user-dot {
            background-image: url('shadow.png');
            width: 50px;
            height: 50px;
        }
        
        .user-dot.close {
            background-image: url('shadow_green.png');
            width: 60px;
            height: 60px;
        }
        
        .fly-dot {
            background-image: url('fly.png');
            width: 50px;
            height: 50px;
        }
        
        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            cursor: auto;
        }
        
        .modal-overlay.hidden {
            display: none;
        }
        
        .modal {
            background: white;
            padding: 30px 25px 70px;
            border-radius: 12px;
            text-align: center;
            width: 340px;
            max-width: 90vw;
            position: relative;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        
        .modal p {
            margin: 0 0 20px;
            font-size: 16px;
            line-height: 1.5;
            color: #333;
        }
        
        .modal-button {
            padding: 12px 28px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            transition: background 0.2s;
        }
        
        .modal-button:hover {
            background: #1d4ed8;
        }
        
        /* HUD Elements */
        .trial-counter {
            position: fixed;
            top: 10px;
            right: 10px;
            color: black;
            padding: 10px;
            font-size: 80px;
            font-weight: bold;
            z-index: 100;
        }
        
        .trial-counter.uploading {
            top: 10px;
            left: 50%;
            right: auto;
            transform: translateX(-50%);
            font-size: 20px;
            text-align: center;
            max-width: 80%;
        }
        
        .countdown-timer {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            font-weight: bold;
            color: white;
            background: black;
            padding: 8px 16px;
            border-radius: 6px;
            z-index: 100;
        }
        
        .countdown-timer.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="dot user-dot" id="userDot"></div>
    <div class="dot fly-dot" id="flyDot"></div>
    
    <div class="modal-overlay" id="modal">
        <div class="modal">
            <p id="modalMessage"></p>
            <button class="modal-button" id="modalButton">OK</button>
        </div>
    </div>
    
    <div class="countdown-timer hidden" id="countdownTimer"></div>
    <div class="trial-counter" id="trialCounter">0</div>

    <script type="module">
        // ============================================================
        // CONFIGURATION - Easy to modify game parameters
        // ============================================================
        const CONFIG = {
            // ----------------------------------------------------------
            // TRIAL COUNTS - How many trials of each type
            // ----------------------------------------------------------
            trials: {
                control: 2,      // Must be even (for upload splitting)
                perturb: 4,      // Must be multiple of 4 (for upload splitting)
                post: 1          // Post-perturbation trials
            },
            
            // ----------------------------------------------------------
            // TRIAL DURATIONS (in milliseconds)
            // ----------------------------------------------------------
            durations: {
                normal: 1000,    // Duration of normal mode trials
                rotate: 1000     // Duration of rotate mode trials
            },
            
            // ----------------------------------------------------------
            // PERTURBATION SETTINGS
            // ----------------------------------------------------------
            perturbation: {
                style: "rotate",           // Options: "rotate", "reverse"
                rotationAngle: Math.PI / 2 // Radians (90 degrees)
            },
            
            // ----------------------------------------------------------
            // SAMPLING & TIMING
            // ----------------------------------------------------------
            sampling: {
                rate: 20,        // Hz (samples per second)
                dt: 2000         // Milliseconds per time unit for fly movement
            },
            
            // ----------------------------------------------------------
            // PROXIMITY THRESHOLD
            // ----------------------------------------------------------
            proximity: {
                closeDistance: 100  // Pixels - distance to be "close" to fly
            },
            
            // ----------------------------------------------------------
            // COUNTDOWN SETTINGS
            // ----------------------------------------------------------
            countdown: {
                duration: 0.5    // Seconds before each trial starts
            },
            
            // ----------------------------------------------------------
            // DATA UPLOAD
            // ----------------------------------------------------------
            upload: {
                enabled: true,   // Set to false to disable Firebase uploads
                showUploadStatus: true
            },
            
            // ----------------------------------------------------------
            // MESSAGES - Easy to customize all game messages
            // ----------------------------------------------------------
            messages: {
                welcome: "Welcome! Get ready to follow the fly. You will have a countdown above before the game begins on each trial. Press OK to begin and go fullscreen",
                trialComplete: "Good job! Click OK to continue the game.",
                controlToPerturb: "Great Job! Now, your controls will be switched! Try to adapt quickly. Click OK to continue.",
                perturbToPost: "Great Job! Now, your controls will switched back to normal! Click OK to continue.",
                uploading: "Please wait for data to be processed and uploaded (It's a lot of data)."
            },
            
            // ----------------------------------------------------------
            // NAVIGATION
            // ----------------------------------------------------------
            navigation: {
                requireConsent: true,      // Redirect if consent not given
                consentPage: "index.html",
                completionPage: "done.html"
            },
            
            // ----------------------------------------------------------
            // FIREBASE STRUCTURE
            // ----------------------------------------------------------
            firebase: {
                // Root collection for this experiment
                experimentCollection: "experiments_v2",
                
                // Subcollection name for trial data
                trialsSubcollection: "trials",
                
                // Document names for each phase
                documentNames: {
                    control: ["control1", "control2"],
                    perturb: ["perturb1", "perturb2", "perturb3", "perturb4"],
                    post: ["post"]
                }
            }
        };

        // ============================================================
        // FLY MOVEMENT PARAMETERS (from original paper)
        // ============================================================
        const FLY_PARAMS = {
            // Y-axis amplitudes (scaled based on screen size)
            amplitudes: {
                y: [2.31, 2.31, 2.31, 1.58, 1.03, 0.81, 0.70],
                x: [2.31, 2.31, 2.31, 1.76, 1.30, 0.97, 0.73]
            },
            // Frequencies for oscillation
            frequencies: {
                y: [0.1, 0.25, 0.55, 0.85, 1.15, 1.55, 2.05],
                x: [0.15, 0.35, 0.65, 0.95, 1.45, 1.85, 2.15]
            },
            // Scale factors for different screen sizes
            scaleFactors: {
                y: { base: 40, smallScreenRatios: [0.2, 0.2, 0.2, 0.15, 0.11, 0.08, 0.06] },
                x: { base: 61, smallScreenRatios: [0.21, 0.21, 0.21, 0.14, 0.09, 0.07, 0.06] }
            },
            // Minimum screen dimensions before scaling kicks in
            minDimensions: { width: 1440, height: 900 }
        };

        // ============================================================
        // GAME STATE - All mutable state in one place
        // ============================================================
        const state = {
            // Screen dimensions
            screen: {
                width: window.screen.width,
                height: window.screen.height
            },
            
            // Positions
            user: { x: 0, y: 0 },
            fly: { x: 0, y: 0 },
            
            // Game progress
            currentMode: "normal",
            trialIndex: 0,
            trialsRemaining: 0,
            postPhaseIndex: -1,  // -1 means not in post phase
            
            // Timing
            trialStartTime: 0,
            
            // Data collection
            trials: {},
            currentTrialData: {
                userPositions: [],
                flyPositions: [],
                distances: []
            },
            allDistances: [],
            phis: [],  // Phase offsets for fly movement
            
            // Animation & intervals
            animationFrame: null,
            recordingInterval: null,
            currentMouseHandler: null,
            
            // Flags
            canNavigate: true
        };

        // ============================================================
        // COMPUTED VALUES (derived from config and screen)
        // ============================================================
        function computeAmplitudes() {
            const { width, height } = state.screen;
            const { amplitudes, scaleFactors, minDimensions } = FLY_PARAMS;
            
            let a_y, a_x;
            
            if (height < minDimensions.height) {
                a_y = scaleFactors.y.smallScreenRatios.map(r => r * height / 2);
            } else {
                a_y = amplitudes.y.map(n => scaleFactors.y.base * n);
            }
            
            if (width < minDimensions.width) {
                a_x = scaleFactors.x.smallScreenRatios.map(r => r * width / 2);
            } else {
                a_x = amplitudes.x.map(n => scaleFactors.x.base * n);
            }
            
            return { a_x, a_y };
        }

        const amplitudes = computeAmplitudes();
        const samplingDelay = 1000 / CONFIG.sampling.rate;

        // ============================================================
        // DOM ELEMENTS
        // ============================================================
        const elements = {
            userDot: document.getElementById('userDot'),
            flyDot: document.getElementById('flyDot'),
            modal: document.getElementById('modal'),
            modalMessage: document.getElementById('modalMessage'),
            modalButton: document.getElementById('modalButton'),
            countdownTimer: document.getElementById('countdownTimer'),
            trialCounter: document.getElementById('trialCounter')
        };

        // ============================================================
        // FIREBASE SETUP
        // ============================================================
        let db, auth;
        let prolificId = localStorage.getItem('prolificId') || "anonymous";

        async function initializeFirebase() {
            const { initializeFirebase: initFB } = await import('./firebaseConfig.js');
            const { doc, setDoc, Timestamp, collection } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
            const { signInAnonymously } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');
            
            const firebase = initFB();
            db = firebase.db;
            auth = firebase.auth;
            
            // Store these for later use
            window.firebaseModules = { doc, setDoc, Timestamp, collection, signInAnonymously };
            
            return firebase;
        }

        // ============================================================
        // CONSENT CHECK
        // ============================================================
        function checkConsent() {
            if (!CONFIG.navigation.requireConsent) return;
            
            if (sessionStorage.getItem('gameStarted') !== 'true') {
                window.location.href = CONFIG.navigation.consentPage;
            } else {
                sessionStorage.removeItem('gameStarted');
            }
        }

        // ============================================================
        // FULLSCREEN & CURSOR
        // ============================================================
        function goFullscreen() {
            const docEl = document.documentElement;
            const requestFS = docEl.requestFullscreen || 
                              docEl.mozRequestFullScreen || 
                              docEl.webkitRequestFullscreen || 
                              docEl.msRequestFullscreen;
            
            if (requestFS) {
                requestFS.call(docEl);
            }
            document.body.style.cursor = 'none';
        }

        function showCursor() {
            document.body.style.cursor = 'auto';
        }

        function hideCursor() {
            document.body.style.cursor = 'none';
        }

        // ============================================================
        // MOUSE MOVEMENT HANDLERS
        // ============================================================
        const mouseHandlers = {
            normal(e) {
                const { width, height } = state.screen;
                state.user.x = Math.max(0, Math.min(width, e.clientX));
                state.user.y = Math.max(0, Math.min(height, e.clientY));
                updateUserDotPosition();
            },
            
            reverse(e) {
                const { width, height } = state.screen;
                state.user.x = Math.max(0, Math.min(width, state.user.x - e.movementX));
                state.user.y = Math.max(0, Math.min(height - 50, state.user.y - e.movementY));
                updateUserDotPosition();
            },
            
            rotate(e) {
                const { width, height } = state.screen;
                const radians = CONFIG.perturbation.rotationAngle;
                
                const rotatedDeltaX = e.movementX * Math.cos(radians) - e.movementY * Math.sin(radians);
                const rotatedDeltaY = e.movementX * Math.sin(radians) + e.movementY * Math.cos(radians);
                
                state.user.x = Math.max(0, Math.min(width, state.user.x + rotatedDeltaX));
                state.user.y = Math.max(0, Math.min(height, state.user.y + rotatedDeltaY));
                updateUserDotPosition();
            }
        };

        function updateUserDotPosition() {
            elements.userDot.style.left = `${state.user.x}px`;
            elements.userDot.style.top = `${state.user.y}px`;
        }

        function setMouseHandler(mode) {
            if (state.currentMouseHandler) {
                document.removeEventListener('mousemove', state.currentMouseHandler);
            }
            
            state.currentMouseHandler = mouseHandlers[mode] || mouseHandlers.normal;
            document.addEventListener('mousemove', state.currentMouseHandler);
        }

        // ============================================================
        // FLY MOVEMENT
        // ============================================================
        function generatePhi() {
            // If in post phase, reuse saved phis
            if (state.postPhaseIndex > -1) {
                return state.phis[state.postPhaseIndex++];
            }
            
            const phi = [];
            for (let i = 0; i < 7; i++) {
                phi.push(Math.random() * 2 * Math.PI - Math.PI);
            }
            return phi;
        }

        function updateFlyPosition(t, phi) {
            const { width, height } = state.screen;
            const { a_x, a_y } = amplitudes;
            const { frequencies } = FLY_PARAMS;
            
            let dx = 0, dy = 0;
            
            for (let i = 0; i < 7; i++) {
                dx += a_x[i] * Math.cos(2 * Math.PI * t * frequencies.x[i] + phi[i]);
                dy += a_y[i] * Math.cos(2 * Math.PI * t * frequencies.y[i] + phi[i]);
            }
            
            state.fly.x = dx + width / 2;
            state.fly.y = dy + height / 2;
            
            elements.flyDot.style.left = `${state.fly.x}px`;
            elements.flyDot.style.top = `${state.fly.y}px`;
        }

        function placeFlyAtStart() {
            const phi = state.phis[state.phis.length - 1];
            updateFlyPosition(0, phi);
        }

        // ============================================================
        // DISTANCE CALCULATIONS
        // ============================================================
        function getDistance() {
            return Math.sqrt(
                Math.pow(state.user.x - state.fly.x, 2) + 
                Math.pow(state.user.y - state.fly.y, 2)
            );
        }

        function calculateDistancePercentages(distances) {
            const maxDistance = Math.max(...distances);
            const sectionSizes = {
                0: Math.round(1 * maxDistance / 15),
                1: Math.round(3 * maxDistance / 15),
                2: Math.round(7 * maxDistance / 15),
                3: Math.round(11 * maxDistance / 15),
                4: Math.round(15 * maxDistance / 15)
            };
            
            const sections = [0, 0, 0, 0, 0];
            
            distances.forEach(distance => {
                if (distance < sectionSizes[0]) sections[0]++;
                else if (distance < sectionSizes[1]) sections[1]++;
                else if (distance < sectionSizes[2]) sections[2]++;
                else if (distance < sectionSizes[3]) sections[3]++;
                else sections[4]++;
            });
            
            const percentages = sections.map(count => (count / distances.length) * 100);
            return { sectionSizes, percentages };
        }

        // ============================================================
        // MODAL SYSTEM
        // ============================================================
        function showModal(message) {
            return new Promise(resolve => {
                elements.modalMessage.textContent = message;
                elements.modal.classList.remove('hidden');
                showCursor();
                
                const handleClick = () => {
                    elements.modalButton.removeEventListener('click', handleClick);
                    hideModal();
                    resolve();
                };
                
                elements.modalButton.addEventListener('click', handleClick);
            });
        }

        function hideModal() {
            elements.modal.classList.add('hidden');
            hideCursor();
        }

        function showStartModal(message) {
            return new Promise(resolve => {
                elements.modalMessage.textContent = message;
                elements.modal.classList.remove('hidden');
                showCursor();
                
                const handleClick = () => {
                    elements.modalButton.removeEventListener('click', handleClick);
                    goFullscreen();
                    hideModal();
                    resolve();
                };
                
                elements.modalButton.addEventListener('click', handleClick);
            });
        }

        // ============================================================
        // COUNTDOWN TIMER
        // ============================================================
        function showCountdown(seconds) {
            return new Promise(resolve => {
                let remaining = seconds;
                
                elements.countdownTimer.textContent = `${remaining}s`;
                elements.countdownTimer.classList.remove('hidden');
                
                const interval = setInterval(() => {
                    remaining = Math.round((remaining * 10 - 1)) / 10;
                    
                    if (remaining <= 0) {
                        clearInterval(interval);
                        elements.countdownTimer.classList.add('hidden');
                        resolve();
                    } else {
                        elements.countdownTimer.textContent = `${remaining}s`;
                    }
                }, 100);
            });
        }

        // ============================================================
        // DATA RECORDING
        // ============================================================
        function startRecording() {
            state.recordingInterval = setInterval(() => {
                const time = Date.now();
                
                state.currentTrialData.userPositions.push({
                    x: state.user.x,
                    y: state.user.y,
                    game_mode: state.currentMode,
                    timestamp: time
                });
                
                state.currentTrialData.flyPositions.push({
                    x: state.fly.x,
                    y: state.fly.y,
                    game_mode: state.currentMode,
                    timestamp: time
                });
                
                state.currentTrialData.distances.push(getDistance());
            }, samplingDelay);
        }

        function stopRecording() {
            if (state.recordingInterval) {
                clearInterval(state.recordingInterval);
                state.recordingInterval = null;
            }
        }

        function saveTrialData() {
            state.trials[state.trialIndex] = {
                userPositions: state.currentTrialData.userPositions,
                flyPositions: state.currentTrialData.flyPositions,
                phis: state.phis[state.phis.length - 1]
            };
            
            state.allDistances.push(state.currentTrialData.distances);
            
            // Reset current trial data
            state.currentTrialData = {
                userPositions: [],
                flyPositions: [],
                distances: []
            };
            
            state.trialIndex++;
        }

        // ============================================================
        // DATA UPLOAD
        // ============================================================
        function showUploadStatus(show) {
            if (!CONFIG.upload.showUploadStatus) return;
            
            if (show) {
                elements.trialCounter.textContent = CONFIG.messages.uploading;
                elements.trialCounter.classList.add('uploading');
            } else {
                elements.trialCounter.textContent = "0";
                elements.trialCounter.classList.remove('uploading');
            }
        }

        async function uploadTrialData(startIndex, endIndex, docName) {
            if (startIndex === endIndex) return;
            
            const { doc, setDoc, Timestamp, collection } = window.firebaseModules;
            const { experimentCollection, trialsSubcollection } = CONFIG.firebase;
            
            const entries = Object.entries(state.trials).slice(startIndex, endIndex);
            const trialData = Object.fromEntries(entries);
            
            // Build user ID: prolificId_visitorUid
            const oderId = `${prolificId}_${auth.currentUser.uid}`;
            
            // Structure: experiments_v2 / oderId / trials / docName
            // First, create/update the user document with metadata
            const userDocRef = doc(db, experimentCollection, oderId);
            await setDoc(userDocRef, {
                oderId: oderId,
                visitorUid: auth.currentUser.uid,
                prolificId: prolificId,
                createdAt: Timestamp.fromDate(new Date()),
                screenWidth: state.screen.width,
                screenHeight: state.screen.height
            }, { merge: true });  // merge to avoid overwriting on subsequent uploads
            
            // Then, add trial data to the trials subcollection
            const trialsCollectionRef = collection(db, experimentCollection, oderId, trialsSubcollection);
            const trialDocRef = doc(trialsCollectionRef, docName);
            
            await setDoc(trialDocRef, {
                trials: trialData,
                uploadedAt: Timestamp.fromDate(new Date()),
                trialType: docName
            });
        }

        async function uploadPhaseData(phase) {
            if (!CONFIG.upload.enabled) return;
            
            showUploadStatus(true);
            
            try {
                const { trials } = CONFIG;
                const docNames = CONFIG.firebase.documentNames;
                
                if (phase === "normal") {
                    const half = Math.floor(trials.control / 2);
                    await uploadTrialData(0, half, docNames.control[0]);
                    await uploadTrialData(half, trials.control, docNames.control[1]);
                } else if (phase === CONFIG.perturbation.style) {
                    const quarter = Math.floor(trials.perturb / 4);
                    const base = trials.control;
                    await uploadTrialData(base, base + quarter, docNames.perturb[0]);
                    await uploadTrialData(base + quarter, base + 2 * quarter, docNames.perturb[1]);
                    await uploadTrialData(base + 2 * quarter, base + 3 * quarter, docNames.perturb[2]);
                    await uploadTrialData(base + 3 * quarter, base + trials.perturb, docNames.perturb[3]);
                } else if (phase === "post") {
                    const base = trials.control + trials.perturb;
                    await uploadTrialData(base, base + trials.post, docNames.post[0]);
                }
                
                console.log(`${phase} phase data uploaded successfully`);
            } catch (error) {
                console.error("Upload error:", error);
                state.canNavigate = false;
            }
            
            showUploadStatus(false);
        }

        // ============================================================
        // GAME LOOP
        // ============================================================
        function gameLoop(phi) {
            if (state.currentMode === "done") {
                finishGame();
                return;
            }
            
            const t = (Date.now() - state.trialStartTime) / CONFIG.sampling.dt;
            updateFlyPosition(t, phi);
            
            // Update user dot appearance based on proximity
            const isClose = getDistance() < CONFIG.proximity.closeDistance;
            elements.userDot.classList.toggle('close', isClose);
            
            state.animationFrame = requestAnimationFrame(() => gameLoop(phi));
        }

        function pauseGame(hideUser = true) {
            // Center user position
            state.user.x = state.screen.width / 2;
            state.user.y = state.screen.height / 2;
            updateUserDotPosition();
            
            cancelAnimationFrame(state.animationFrame);
            
            if (hideUser) {
                elements.userDot.style.visibility = 'hidden';
            }
        }

        function resumeGame(generateNewPhi = true) {
            setMouseHandler(state.currentMode === CONFIG.perturbation.style ? 
                           CONFIG.perturbation.style : 'normal');
            
            elements.userDot.style.visibility = 'visible';
            
            if (generateNewPhi) {
                const phi = generatePhi();
                state.phis.push(phi);
            }
            
            state.trialStartTime = Date.now();
            gameLoop(state.phis[state.phis.length - 1]);
        }

        // ============================================================
        // TRIAL MANAGEMENT
        // ============================================================
        async function runTrials(mode, count, isFinalPhase) {
            const duration = CONFIG.durations[mode] || CONFIG.durations.normal;
            
            startRecording();
            
            for (let i = 0; i < count; i++) {
                const isLastTrial = i === count - 1;
                
                elements.trialCounter.textContent = state.trialsRemaining;
                state.trialsRemaining--;
                state.trialStartTime = Date.now();
                
                // Wait for trial duration
                await new Promise(resolve => setTimeout(resolve, duration));
                
                pauseGame();
                stopRecording();
                saveTrialData();
                
                if (isFinalPhase && isLastTrial) {
                    // Final trial of the entire game
                    state.currentMode = "done";
                } else if (isLastTrial) {
                    // Last trial of this phase - show phase transition message
                    const message = mode === CONFIG.perturbation.style ? 
                                   CONFIG.messages.perturbToPost : 
                                   CONFIG.messages.controlToPerturb;
                    
                    await uploadPhaseData(state.currentMode);
                    await showModal(message);
                } else {
                    // Regular trial completion
                    await showModal(CONFIG.messages.trialComplete);
                    placeFlyAtStart();
                    await showCountdown(CONFIG.countdown.duration);
                    startRecording();
                }
            }
        }

        async function runGame() {
            const { trials } = CONFIG;
            state.trialsRemaining = trials.control + trials.perturb + trials.post;
            
            // Phase 1: Control trials
            state.currentMode = "normal";
            setMouseHandler('normal');
            placeFlyAtStart();
            await showCountdown(CONFIG.countdown.duration);
            await runTrials("normal", trials.control, false);
            
            // Phase 2: Perturbation trials
            state.currentMode = CONFIG.perturbation.style;
            setMouseHandler(CONFIG.perturbation.style);
            placeFlyAtStart();
            await showCountdown(CONFIG.countdown.duration);
            await runTrials(CONFIG.perturbation.style, trials.perturb, false);
            
            // Phase 3: Post trials (reusing control phis)
            state.currentMode = "normal";
            state.postPhaseIndex = 0;
            setMouseHandler('normal');
            await showCountdown(CONFIG.countdown.duration);
            await runTrials("normal", trials.post, true);
        }

        // ============================================================
        // GAME COMPLETION
        // ============================================================
        function getHighlights() {
            const flatDistances = state.allDistances.flat();
            const { trials } = CONFIG;
            
            const cumulativeLengths = state.allDistances.reduce((acc, arr) => {
                acc.push((acc.length > 0 ? acc[acc.length - 1] : 0) + arr.length);
                return acc;
            }, []);
            
            const highlights = [
                cumulativeLengths[trials.control - 1],
                cumulativeLengths[trials.control + trials.perturb - 1],
                cumulativeLengths[trials.control + trials.perturb + trials.post - 1]
            ];
            
            return { flatDistances, highlights };
        }

        async function finishGame() {
            console.log("Game complete");
            
            const { flatDistances, highlights } = getHighlights();
            const { sectionSizes, percentages } = calculateDistancePercentages(flatDistances);
            
            // Store results for completion page
            localStorage.setItem('sectionSizes', JSON.stringify(Object.values(sectionSizes)));
            localStorage.setItem('percentages', JSON.stringify(percentages));
            localStorage.setItem('distances', JSON.stringify(flatDistances));
            localStorage.setItem('game_timelegths', JSON.stringify(CONFIG.durations));
            localStorage.setItem('highlights', JSON.stringify(highlights));
            
            await uploadPhaseData("post");
            
            if (state.canNavigate) {
                window.location.href = CONFIG.navigation.completionPage;
            }
        }

        // ============================================================
        // INITIALIZATION
        // ============================================================
        async function initialize() {
            checkConsent();
            
            // Initialize positions
            state.user.x = state.screen.width / 2;
            state.user.y = state.screen.height / 2;
            state.fly.x = state.screen.width / 2;
            state.fly.y = state.screen.height / 2;
            
            // Position dots
            updateUserDotPosition();
            elements.flyDot.style.left = `${state.fly.x}px`;
            elements.flyDot.style.top = `${state.fly.y}px`;
            
            try {
                await initializeFirebase();
                await window.firebaseModules.signInAnonymously(auth);
                console.log("User signed in anonymously");
                
                await showStartModal(CONFIG.messages.welcome);
                
                // Generate initial phi and start game
                setMouseHandler('normal');
                const phi = generatePhi();
                state.phis.push(phi);
                placeFlyAtStart();
                
                state.trialStartTime = Date.now();
                gameLoop(phi);
                
                await runGame();
            } catch (error) {
                console.error("Initialization error:", error);
            }
        }

        // Start the game
        initialize();
    </script>
</body>
</html>