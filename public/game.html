<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mouse Follower Dot</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            height: 100vh;
            cursor: none;
            font-family: system-ui, -apple-system, sans-serif;
        }
        
        .dot {
            position: absolute;
            pointer-events: none;
            transform: translate(-50%, -50%);
            background-color: transparent;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            border: none;
        }
        
        .user-dot {
            background-image: url('shadow.png');
            width: 50px;
            height: 50px;
        }
        
        .user-dot.close {
            background-image: url('shadow_green.png');
            width: 60px;
            height: 60px;
        }
        
        .fly-dot {
            background-image: url('fly.png');
            width: 50px;
            height: 50px;
        }
        
        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            cursor: auto;
        }
        
        .modal-overlay.hidden {
            display: none;
        }
        
        .modal {
            background: white;
            padding: 30px 25px 70px;
            border-radius: 12px;
            text-align: center;
            width: 340px;
            max-width: 90vw;
            position: relative;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        
        .modal p {
            margin: 0 0 20px;
            font-size: 16px;
            line-height: 1.5;
            color: #333;
        }
        
        .modal-button {
            padding: 12px 28px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            transition: background 0.2s;
        }
        
        .modal-button:hover {
            background: #1d4ed8;
        }
        
        /* HUD Elements */
        .trial-counter {
            position: fixed;
            top: 10px;
            right: 10px;
            color: black;
            padding: 10px;
            font-size: 80px;
            font-weight: bold;
            z-index: 100;
        }
        
        .trial-counter.uploading {
            top: 10px;
            left: 50%;
            right: auto;
            transform: translateX(-50%);
            font-size: 20px;
            text-align: center;
            max-width: 80%;
        }
        
        .countdown-timer {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            font-weight: bold;
            color: white;
            background: black;
            padding: 8px 16px;
            border-radius: 6px;
            z-index: 100;
        }
        
        .countdown-timer.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="dot user-dot" id="userDot"></div>
    <div class="dot fly-dot" id="flyDot"></div>
    
    <div class="modal-overlay" id="modal">
        <div class="modal">
            <p id="modalMessage"></p>
            <button class="modal-button" id="modalButton">OK</button>
        </div>
    </div>
    
    <div class="countdown-timer hidden" id="countdownTimer"></div>
    <div class="trial-counter" id="trialCounter">0</div>

    <script type="module">
        // ============================================================
        // CONFIGURATION - Easy to modify game parameters
        // ============================================================
        const CONFIG = {
            // PERTURBATION SETTINGS
            // ----------------------------------------------------------
            perturbation: {
                // Rotation ramp: starts at 0, increases by 1 degree per ramp trial
                degreesPerTrial: 1,      // Degrees added per ramp trial
                maxDegrees: 30,          // Maximum rotation (held during hold phase)
            },

            // ----------------------------------------------------------
            // TRIAL COUNTS - How many trials of each type
            // ----------------------------------------------------------
            trials: {
                baseline: 16,        // Feedback baseline (no rotation)
                rampUp: 30,          // Gradual rotation increase (1 deg per trial)
                hold: 6,             // Hold at max rotation
                aftereffect: 4       // Post trials (no rotation)
            },
            
            // ----------------------------------------------------------
            // TRIAL DURATIONS (in milliseconds)
            // ----------------------------------------------------------
            durations: {
                trialLength: 30000   // 30 seconds per trial
            },
            
            
            // ----------------------------------------------------------
            // SAMPLING & TIMING
            // ----------------------------------------------------------
            sampling: {
                rate: 20,        // Hz (samples per second)
                dt: 2000         // Milliseconds per time unit for fly movement
            },
            
            // ----------------------------------------------------------
            // PROXIMITY THRESHOLD
            // ----------------------------------------------------------
            proximity: {
                closeDistance: 100  // Pixels - distance to be "close" to fly
            },
            
            // ----------------------------------------------------------
            // COUNTDOWN SETTINGS
            // ----------------------------------------------------------
            countdown: {
                duration: 0.5    // Seconds before each trial starts
            },
            
            // ----------------------------------------------------------
            // DATA UPLOAD
            // ----------------------------------------------------------
            upload: {
                enabled: true,   // Set to false to disable Firebase uploads
                showUploadStatus: true
            },
            
            // ----------------------------------------------------------
            // MESSAGES - Easy to customize all game messages
            // ----------------------------------------------------------
            messages: {
                get welcome() {
                    const hand = localStorage.getItem('hand_to_use') || "dominant";
                    
                    return `Welcome! Please use your <strong>${hand}</strong> hand when playing this. Get ready to follow the fly. Press OK to begin and go fullscreen`;
                },
                trialComplete: "Good job! Click OK to continue the game.",
                baselineToRamp: "Great job! The controls may start to feel different. Try to adapt as you go. Click OK to continue.",
                rampToHold: "Great job! Keep going! Click OK to continue.",
                holdToAftereffect: "Great job! Now your controls are back to normal. Click OK to continue.",
                uploading: "Please wait for data to be processed and uploaded..."
            },
            
            // ----------------------------------------------------------
            // NAVIGATION
            // ----------------------------------------------------------
            navigation: {
                requireConsent: true,      // Redirect if consent not given
                consentPage: "index.html",
                completionPage: "done.html"
            },
            
            // ----------------------------------------------------------
            // FIREBASE STRUCTURE
            // ----------------------------------------------------------
            firebase: {
                // Root collection for this experiment
                experimentCollection: localStorage.getItem('collection_name'),
                
                // Subcollection name for trial data
                trialsSubcollection: "trials",
                
                // Document names for each phase (will be auto-generated based on trial counts)
                // baseline: baseline_1, baseline_2, ... baseline_16
                // rampUp: ramp_1, ramp_2, ... ramp_30
                // hold: hold_1, hold_2, ... hold_6
                // aftereffect: aftereffect_1, aftereffect_2, ... aftereffect_4
                documentPrefixes: {
                    baseline: "baseline",
                    rampUp: "ramp",
                    hold: "hold",
                    aftereffect: "aftereffect"
                },
                // How many trials to batch per upload (to stay under Firestore limits)
                trialsPerUpload: 4
            }
        };

        // ============================================================
        // FLY MOVEMENT PARAMETERS (from original paper)
        // ============================================================
        const FLY_PARAMS = {
            // Y-axis amplitudes (scaled based on screen size)
            amplitudes: {
                y: [2.31, 2.31, 2.31, 1.58, 1.03, 0.81, 0.70],
                x: [2.31, 2.31, 2.31, 1.76, 1.30, 0.97, 0.73]
            },
            // Frequencies for oscillation
            frequencies: {
                y: [0.1, 0.25, 0.55, 0.85, 1.15, 1.55, 2.05],
                x: [0.15, 0.35, 0.65, 0.95, 1.45, 1.85, 2.15]
            },
            // Scale factors for different screen sizes
            scaleFactors: {
                y: { base: 40, smallScreenRatios: [0.2, 0.2, 0.2, 0.15, 0.11, 0.08, 0.06] },
                x: { base: 61, smallScreenRatios: [0.21, 0.21, 0.21, 0.14, 0.09, 0.07, 0.06] }
            },
            // Minimum screen dimensions before scaling kicks in
            minDimensions: { width: 1440, height: 900 }
        };

        // ============================================================
        // GAME STATE - All mutable state in one place
        // ============================================================
        const state = {
            // Screen dimensions
            screen: {
                width: window.screen.width,
                height: window.screen.height
            },
            
            // Positions
            user: { x: 0, y: 0 },
            fly: { x: 0, y: 0 },
            
            // Game progress
            currentPhase: "baseline",  // baseline, rampUp, hold, aftereffect, done
            currentRotationDegrees: 0, // Current rotation in degrees
            trialIndex: 0,
            trialsRemaining: 0,
            phaseTrialIndex: 0,        // Trial index within current phase
            
            // Timing
            trialStartTime: 0,
            
            // Data collection
            trials: {},
            currentTrialData: {
                userPositions: [],
                flyPositions: [],
                distances: [],
                rotationDegrees: 0     // Track rotation for this trial
            },
            allDistances: [],
            phis: [],  // Phase offsets for fly movement
            
            // Animation & intervals
            animationFrame: null,
            recordingInterval: null,
            currentMouseHandler: null,
            
            // Flags
            canNavigate: true
        };

        // ============================================================
        // COMPUTED VALUES (derived from config and screen)
        // ============================================================
        function computeAmplitudes() {
            const { width, height } = state.screen;
            const { amplitudes, scaleFactors, minDimensions } = FLY_PARAMS;
            
            let a_y, a_x;
            
            if (height < minDimensions.height) {
                a_y = scaleFactors.y.smallScreenRatios.map(r => r * height / 2);
            } else {
                a_y = amplitudes.y.map(n => scaleFactors.y.base * n);
            }
            
            if (width < minDimensions.width) {
                a_x = scaleFactors.x.smallScreenRatios.map(r => r * width / 2);
            } else {
                a_x = amplitudes.x.map(n => scaleFactors.x.base * n);
            }
            
            return { a_x, a_y };
        }

        const amplitudes = computeAmplitudes();
        const samplingDelay = 1000 / CONFIG.sampling.rate;

        // ============================================================
        // DOM ELEMENTS
        // ============================================================
        const elements = {
            userDot: document.getElementById('userDot'),
            flyDot: document.getElementById('flyDot'),
            modal: document.getElementById('modal'),
            modalMessage: document.getElementById('modalMessage'),
            modalButton: document.getElementById('modalButton'),
            countdownTimer: document.getElementById('countdownTimer'),
            trialCounter: document.getElementById('trialCounter')
        };

        // ============================================================
        // FIREBASE SETUP
        // ============================================================
        let db, auth;
        let prolificId = localStorage.getItem('prolificId') || "anonymous";

        async function initializeFirebase() {
            const { initializeFirebase: initFB } = await import('./firebaseConfig.js');
            const { doc, setDoc, Timestamp, collection } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
            const { signInAnonymously } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');
            
            const firebase = initFB();
            db = firebase.db;
            auth = firebase.auth;
            
            // Store these for later use
            window.firebaseModules = { doc, setDoc, Timestamp, collection, signInAnonymously };
            
            return firebase;
        }

        // ============================================================
        // CONSENT CHECK
        // ============================================================
        function checkConsent() {
            if (!CONFIG.navigation.requireConsent) return;
            
            if (sessionStorage.getItem('gameStarted') !== 'true') {
                window.location.href = CONFIG.navigation.consentPage;
            } else {
                sessionStorage.removeItem('gameStarted');
            }
        }

        // ============================================================
        // FULLSCREEN & CURSOR & POINTER LOCK
        // ============================================================
        function goFullscreen() {
            const docEl = document.documentElement;
            const requestFS = docEl.requestFullscreen || 
                              docEl.mozRequestFullScreen || 
                              docEl.webkitRequestFullscreen || 
                              docEl.msRequestFullscreen;
            
            if (requestFS) {
                requestFS.call(docEl);
            }
            document.body.style.cursor = 'none';
        }

        function showCursor() {
            document.body.style.cursor = 'auto';
            // Exit pointer lock when showing cursor (for modals)
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
        }

        function hideCursor() {
            document.body.style.cursor = 'none';
        }
        
        function requestPointerLock() {
            // Request pointer lock for consistent mouse tracking
            const body = document.body;
            body.requestPointerLock = body.requestPointerLock || 
                                      body.mozRequestPointerLock || 
                                      body.webkitRequestPointerLock;
            if (body.requestPointerLock) {
                body.requestPointerLock();
            }
        }

        // ============================================================
        // MOUSE MOVEMENT HANDLERS
        // ============================================================
        function degreesToRadians(degrees) {
            return degrees * (Math.PI / 180);
        }
        
        const mouseHandlers = {
            // Normal mode: use movement deltas (works with pointer lock)
            normal(e) {
                const { width, height } = state.screen;
                
                // Use movementX/Y for consistent behavior with pointer lock
                state.user.x += e.movementX;
                state.user.y += e.movementY;
                
                // Clamp to screen bounds
                state.user.x = Math.max(0, Math.min(width, state.user.x));
                state.user.y = Math.max(0, Math.min(height, state.user.y));
                
                updateUserDotPosition();
            },
            
            rotate(e) {
                const { width, height } = state.screen;
                const radians = degreesToRadians(state.currentRotationDegrees);
                
                const rotatedDeltaX = e.movementX * Math.cos(radians) - e.movementY * Math.sin(radians);
                const rotatedDeltaY = e.movementX * Math.sin(radians) + e.movementY * Math.cos(radians);
                
                state.user.x += rotatedDeltaX;
                state.user.y += rotatedDeltaY;
                
                // Clamp to screen bounds
                state.user.x = Math.max(0, Math.min(width, state.user.x));
                state.user.y = Math.max(0, Math.min(height, state.user.y));
                
                updateUserDotPosition();
            }
        };

        function updateUserDotPosition() {
            elements.userDot.style.left = `${state.user.x}px`;
            elements.userDot.style.top = `${state.user.y}px`;
        }

        function setMouseHandler(useRotation) {
            if (state.currentMouseHandler) {
                document.removeEventListener('mousemove', state.currentMouseHandler);
            }
            
            state.currentMouseHandler = useRotation ? mouseHandlers.rotate : mouseHandlers.normal;
            document.addEventListener('mousemove', state.currentMouseHandler);
        }

        // ============================================================
        // FLY MOVEMENT
        // ============================================================
        function generatePhi() {
            const phi = [];
            for (let i = 0; i < 7; i++) {
                phi.push(Math.random() * 2 * Math.PI - Math.PI);
            }
            return phi;
        }

        function updateFlyPosition(t, phi) {
            const { width, height } = state.screen;
            const { a_x, a_y } = amplitudes;
            const { frequencies } = FLY_PARAMS;
            
            let dx = 0, dy = 0;
            
            for (let i = 0; i < 7; i++) {
                dx += a_x[i] * Math.cos(2 * Math.PI * t * frequencies.x[i] + phi[i]);
                dy += a_y[i] * Math.cos(2 * Math.PI * t * frequencies.y[i] + phi[i]);
            }
            
            state.fly.x = dx + width / 2;
            state.fly.y = dy + height / 2;
            
            elements.flyDot.style.left = `${state.fly.x}px`;
            elements.flyDot.style.top = `${state.fly.y}px`;
        }

        function placeFlyAtStart() {
            const phi = state.phis[state.phis.length - 1];
            updateFlyPosition(0, phi);
        }

        // ============================================================
        // DISTANCE CALCULATIONS
        // ============================================================
        function getDistance() {
            return Math.sqrt(
                Math.pow(state.user.x - state.fly.x, 2) + 
                Math.pow(state.user.y - state.fly.y, 2)
            );
        }

        function calculateDistancePercentages(distances) {
            const maxDistance = Math.max(...distances);
            const sectionSizes = {
                0: Math.round(1 * maxDistance / 15),
                1: Math.round(3 * maxDistance / 15),
                2: Math.round(7 * maxDistance / 15),
                3: Math.round(11 * maxDistance / 15),
                4: Math.round(15 * maxDistance / 15)
            };
            
            const sections = [0, 0, 0, 0, 0];
            
            distances.forEach(distance => {
                if (distance < sectionSizes[0]) sections[0]++;
                else if (distance < sectionSizes[1]) sections[1]++;
                else if (distance < sectionSizes[2]) sections[2]++;
                else if (distance < sectionSizes[3]) sections[3]++;
                else sections[4]++;
            });
            
            const percentages = sections.map(count => (count / distances.length) * 100);
            return { sectionSizes, percentages };
        }

        // ============================================================
        // MODAL SYSTEM
        // ============================================================
        function showModal(message) {
            return new Promise(resolve => {
                elements.modalMessage.innerHTML = message;
                elements.modal.classList.remove('hidden');
                showCursor();
                
                const handleClick = () => {
                    elements.modalButton.removeEventListener('click', handleClick);
                    hideModal();
                    resolve();
                };
                
                elements.modalButton.addEventListener('click', handleClick);
            });
        }

        function hideModal() {
            elements.modal.classList.add('hidden');
            hideCursor();
        }

        function showStartModal(message) {
            return new Promise(resolve => {
                elements.modalMessage.innerHTML = message;
                elements.modal.classList.remove('hidden');
                showCursor();
                
                const handleClick = () => {
                    elements.modalButton.removeEventListener('click', handleClick);
                    goFullscreen();
                    hideModal();
                    resolve();
                };
                
                elements.modalButton.addEventListener('click', handleClick);
            });
        }

        // ============================================================
        // COUNTDOWN TIMER
        // ============================================================
        function showCountdown(seconds) {
            return new Promise(resolve => {
                let remaining = seconds;
                
                elements.countdownTimer.textContent = `${remaining}s`;
                elements.countdownTimer.classList.remove('hidden');
                
                const interval = setInterval(() => {
                    remaining = Math.round((remaining * 10 - 1)) / 10;
                    
                    if (remaining <= 0) {
                        clearInterval(interval);
                        elements.countdownTimer.classList.add('hidden');
                        resolve();
                    } else {
                        elements.countdownTimer.textContent = `${remaining}s`;
                    }
                }, 100);
            });
        }

        // ============================================================
        // DATA RECORDING
        // ============================================================
        function startRecording() {
            state.recordingInterval = setInterval(() => {
                const time = Date.now();
                
                state.currentTrialData.userPositions.push({
                    x: state.user.x,
                    y: state.user.y,
                    phase: state.currentPhase,
                    rotationDegrees: state.currentRotationDegrees,
                    timestamp: time
                });
                
                state.currentTrialData.flyPositions.push({
                    x: state.fly.x,
                    y: state.fly.y,
                    phase: state.currentPhase,
                    timestamp: time
                });
                
                state.currentTrialData.distances.push(getDistance());
            }, samplingDelay);
        }

        function stopRecording() {
            if (state.recordingInterval) {
                clearInterval(state.recordingInterval);
                state.recordingInterval = null;
            }
        }

        function saveTrialData() {
            state.trials[state.trialIndex] = {
                userPositions: state.currentTrialData.userPositions,
                flyPositions: state.currentTrialData.flyPositions,
                phis: state.phis[state.phis.length - 1],
                phase: state.currentPhase,
                rotationDegrees: state.currentRotationDegrees,
                phaseTrialIndex: state.phaseTrialIndex
            };
            
            state.allDistances.push(state.currentTrialData.distances);
            
            // Reset current trial data
            state.currentTrialData = {
                userPositions: [],
                flyPositions: [],
                distances: [],
                rotationDegrees: 0
            };
            
            state.trialIndex++;
            state.phaseTrialIndex++;
        }

        // ============================================================
        // DATA UPLOAD
        // ============================================================
        function showUploadStatus(show) {
            if (!CONFIG.upload.showUploadStatus) return;
            
            if (show) {
                elements.trialCounter.textContent = CONFIG.messages.uploading;
                elements.trialCounter.classList.add('uploading');
            } else {
                elements.trialCounter.textContent = "0";
                elements.trialCounter.classList.remove('uploading');
            }
        }

        async function uploadTrialData(startIndex, endIndex, docName) {
            if (startIndex === endIndex) return;
            
            const { doc, setDoc, Timestamp, collection } = window.firebaseModules;
            const { experimentCollection, trialsSubcollection } = CONFIG.firebase;
            
            const entries = Object.entries(state.trials).slice(startIndex, endIndex);
            const trialData = Object.fromEntries(entries);
            
            // Build user ID: prolificId_visitorUid
            const oderId = `${prolificId}_${auth.currentUser.uid}`;
            
            // Structure: experiments_v2 / oderId / trials / docName
            // First, create/update the user document with metadata
            const userDocRef = doc(db, experimentCollection, oderId);
            await setDoc(userDocRef, {
                oderId: oderId,
                visitorUid: auth.currentUser.uid,
                prolificId: prolificId,
                createdAt: Timestamp.fromDate(new Date()),
                screenWidth: state.screen.width,
                screenHeight: state.screen.height,
                trialConfig: CONFIG.trials,
                perturbationConfig: CONFIG.perturbation
            }, { merge: true });
            
            // Then, add trial data to the trials subcollection
            const trialsCollectionRef = collection(db, experimentCollection, oderId, trialsSubcollection);
            const trialDocRef = doc(trialsCollectionRef, docName);
            
            await setDoc(trialDocRef, {
                trials: trialData,
                uploadedAt: Timestamp.fromDate(new Date()),
                trialType: docName
            });
        }

        async function uploadPhaseData(phase, startTrialIndex, endTrialIndex) {
            if (!CONFIG.upload.enabled) return;
            
            showUploadStatus(true);
            
            try {
                const { documentPrefixes, trialsPerUpload } = CONFIG.firebase;
                const prefix = documentPrefixes[phase];
                const totalTrials = endTrialIndex - startTrialIndex;
                
                // Upload in batches
                let batchNum = 1;
                for (let i = startTrialIndex; i < endTrialIndex; i += trialsPerUpload) {
                    const batchEnd = Math.min(i + trialsPerUpload, endTrialIndex);
                    const docName = `${prefix}_batch${batchNum}`;
                    await uploadTrialData(i, batchEnd, docName);
                    batchNum++;
                }
                
                console.log(`${phase} phase data uploaded successfully (${totalTrials} trials)`);
            } catch (error) {
                console.error("Upload error:", error);
                state.canNavigate = false;
            }
            
            showUploadStatus(false);
        }

        // ============================================================
        // GAME LOOP
        // ============================================================
        function gameLoop(phi) {
            if (state.currentPhase === "done") {
                finishGame();
                return;
            }
            
            const t = (Date.now() - state.trialStartTime) / CONFIG.sampling.dt;
            updateFlyPosition(t, phi);
            
            // Update user dot appearance based on proximity
            const isClose = getDistance() < CONFIG.proximity.closeDistance;
            elements.userDot.classList.toggle('close', isClose);
            
            state.animationFrame = requestAnimationFrame(() => gameLoop(phi));
        }

        function pauseGame(hideUser = true) {
            cancelAnimationFrame(state.animationFrame);
            
            // Reset user position to center of screen
            state.user.x = state.screen.width / 2;
            state.user.y = state.screen.height / 2;
            updateUserDotPosition();
            
            if (hideUser) {
                elements.userDot.style.visibility = 'hidden';
            }
            
            // Exit pointer lock when pausing
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
        }

        function resumeGame(generateNewPhi = true) {
            // Use rotation handler if we have any rotation, otherwise normal
            setMouseHandler(state.currentRotationDegrees > 0);
            
            elements.userDot.style.visibility = 'visible';
            
            // Request pointer lock for consistent mouse tracking
            requestPointerLock();
            
            if (generateNewPhi) {
                const phi = generatePhi();
                state.phis.push(phi);
            }
            
            state.trialStartTime = Date.now();
            gameLoop(state.phis[state.phis.length - 1]);
        }

        // ============================================================
        // ROTATION MANAGEMENT
        // ============================================================
        function updateRotationForPhase(phase, trialIndexInPhase) {
            const { degreesPerTrial, maxDegrees } = CONFIG.perturbation;
            
            switch (phase) {
                case "baseline":
                    state.currentRotationDegrees = 0;
                    break;
                case "rampUp":
                    // Increase by 1 degree per trial (trial 0 = 1 deg, trial 29 = 30 deg)
                    state.currentRotationDegrees = (trialIndexInPhase + 1) * degreesPerTrial;
                    break;
                case "hold":
                    state.currentRotationDegrees = maxDegrees;
                    break;
                case "aftereffect":
                    state.currentRotationDegrees = 0;
                    break;
                default:
                    state.currentRotationDegrees = 0;
            }
            
            console.log(`Phase: ${phase}, Trial: ${trialIndexInPhase + 1}, Rotation: ${state.currentRotationDegrees}Â°`);
        }

        // ============================================================
        // TRIAL MANAGEMENT
        // ============================================================
        async function runSingleTrial() {
            const duration = CONFIG.durations.trialLength;
            
            elements.trialCounter.textContent = state.trialsRemaining;
            state.trialStartTime = Date.now();
            
            // Wait for trial duration
            await new Promise(resolve => setTimeout(resolve, duration));
            
            pauseGame();
            stopRecording();
            saveTrialData();
            state.trialsRemaining--;
        }

        async function runPhase(phase, trialCount, nextPhase, transitionMessage) {
            state.currentPhase = phase;
            state.phaseTrialIndex = 0;
            
            const phaseStartIndex = state.trialIndex;
            
            for (let i = 0; i < trialCount; i++) {
                // Update rotation for this specific trial
                updateRotationForPhase(phase, i);
                
                // Set mouse handler based on rotation
                setMouseHandler(state.currentRotationDegrees > 0);
                
                // Generate phi and place fly
                const phi = generatePhi();
                state.phis.push(phi);
                placeFlyAtStart();
                
                // Reset user position to center before each trial
                state.user.x = state.screen.width / 2;
                state.user.y = state.screen.height / 2;
                updateUserDotPosition();
                
                // Show user dot so they can see their starting position during countdown
                elements.userDot.style.visibility = 'visible';
                
                // Countdown before trial
                await showCountdown(CONFIG.countdown.duration);
                
                // Request pointer lock and start recording
                requestPointerLock();
                startRecording();
                resumeGame(false); // Don't generate new phi, we already did
                await runSingleTrial();
                
                const isLastTrialOfPhase = i === trialCount - 1;
                
                if (isLastTrialOfPhase) {
                    // Upload this phase's data
                    await uploadPhaseData(phase, phaseStartIndex, state.trialIndex);
                    
                    // Show transition message if there's a next phase
                    if (nextPhase !== "done") {
                        await showModal(transitionMessage);
                    }
                } else {
                    // Regular trial completion
                    await showModal(CONFIG.messages.trialComplete);
                }
            }
            
            return nextPhase;
        }

        async function runGame() {
            const { trials } = CONFIG;
            const { messages } = CONFIG;
            
            state.trialsRemaining = trials.baseline + trials.rampUp + trials.hold + trials.aftereffect;
            
            // Phase 1: Baseline (no rotation)
            await runPhase(
                "baseline", 
                trials.baseline, 
                "rampUp", 
                messages.baselineToRamp
            );
            
            // Phase 2: Ramp Up (1 degree per trial, 1-30 degrees)
            await runPhase(
                "rampUp", 
                trials.rampUp, 
                "hold", 
                messages.rampToHold
            );
            
            // Phase 3: Hold (stay at 30 degrees)
            await runPhase(
                "hold", 
                trials.hold, 
                "aftereffect", 
                messages.holdToAftereffect
            );
            
            // Phase 4: Aftereffect (no rotation)
            await runPhase(
                "aftereffect", 
                trials.aftereffect, 
                "done", 
                ""
            );
            
            // Game complete
            state.currentPhase = "done";
            finishGame();
        }

        // ============================================================
        // GAME COMPLETION
        // ============================================================
        function getHighlights() {
            const flatDistances = state.allDistances.flat();
            const { trials } = CONFIG;
            
            const cumulativeLengths = state.allDistances.reduce((acc, arr) => {
                acc.push((acc.length > 0 ? acc[acc.length - 1] : 0) + arr.length);
                return acc;
            }, []);
            
            // Highlights at end of each phase
            const highlights = [
                cumulativeLengths[trials.baseline - 1],                                          // End of baseline
                cumulativeLengths[trials.baseline + trials.rampUp - 1],                          // End of ramp
                cumulativeLengths[trials.baseline + trials.rampUp + trials.hold - 1],            // End of hold
                cumulativeLengths[trials.baseline + trials.rampUp + trials.hold + trials.aftereffect - 1]  // End of aftereffect
            ];
            
            return { flatDistances, highlights };
        }

        async function finishGame() {
            console.log("Game complete");
            
            const { flatDistances, highlights } = getHighlights();
            const { sectionSizes, percentages } = calculateDistancePercentages(flatDistances);
            
            // Store results for completion page
            localStorage.setItem('sectionSizes', JSON.stringify(Object.values(sectionSizes)));
            localStorage.setItem('percentages', JSON.stringify(percentages));
            localStorage.setItem('distances', JSON.stringify(flatDistances));
            localStorage.setItem('game_config', JSON.stringify({
                trials: CONFIG.trials,
                durations: CONFIG.durations,
                perturbation: CONFIG.perturbation
            }));
            localStorage.setItem('highlights', JSON.stringify(highlights));
            
            if (state.canNavigate) {
                window.location.href = CONFIG.navigation.completionPage;
            }
        }

        // ============================================================
        // INITIALIZATION
        // ============================================================
        async function initialize() {
            checkConsent();
            
            // Initialize positions
            state.user.x = state.screen.width / 2;
            state.user.y = state.screen.height / 2;
            state.fly.x = state.screen.width / 2;
            state.fly.y = state.screen.height / 2;
            
            // Position dots
            updateUserDotPosition();
            elements.flyDot.style.left = `${state.fly.x}px`;
            elements.flyDot.style.top = `${state.fly.y}px`;
            
            try {
                await initializeFirebase();
                await window.firebaseModules.signInAnonymously(auth);
                console.log("User signed in anonymously");
                
                await showStartModal(CONFIG.messages.welcome);
                
                // Start the game
                await runGame();
            } catch (error) {
                console.error("Initialization error:", error);
            }
        }

        // Start the game
        initialize();
    </script>
</body>
</html>