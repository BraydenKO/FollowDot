<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mouse Follower Dot</title>
    <style>
        body { margin: 0; overflow: hidden; height: 100vh; cursor: none; }
        .user-dot, .random-dot { position: absolute; 
                                width: 20px; height: 20px; 
                                background-color: red; 
                                border-radius: 50%; 
                                pointer-events: none; 
                                transform: translate(-50%, -50%); 
                                border: 2px solid black;; }
        .random-dot { background-color: green; }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none; /* Initially hidden */
            align-items: center;
            justify-content: center;
            z-index: 1000;
            cursor: auto; /* Ensure cursor is visible */
        }

        /* Modal box */
        .modal {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            width: 300px;
            position: relative;
        }

        /* Centered OK button */
        .ok-button {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: blue;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="user-dot"></div>
    <div class="random-dot"></div>
    <div class="modal-overlay" id="customAlert">
        <div class="modal">
            <p>Your controls have been switched! Try to adapt quickly. Click OK to continue.</p>
            <button class="ok-button" id="okButton">OK</button>
        </div>
    </div>

    <script type="module">
        //document.getElementById('customAlert').style.display = 'none';
        //TODO Add COMMENTS!!!
        let do_upload = true


        
        if (sessionStorage.getItem('gameStarted') !== 'true') {
            window.location.href = 'index.html';
        } else {
            // Clear the flag to prevent re-entry
            sessionStorage.removeItem('gameStarted');
        }

        import { initializeFirebase } from './firebaseConfig.js';
        import { doc, setDoc, Timestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { signInAnonymously } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';

        const { db, auth } = initializeFirebase();

        let game_type = "normal";

        
        const game_type_lengths = {
            "normal": 20_000, // ms
            "reverse": 20_000,
        }

        const userDot = document.querySelector('.user-dot');
        const randomDot = document.querySelector('.random-dot');
        const width = window.innerWidth;
        const height = window.innerHeight;

        let x = width / 2;
        let y = height / 2;
        let vx = (Math.random() - 0.5) * 2;
        let vy = (Math.random() - 0.5) * 2;
        const speeds = [4,5,6];
        const turnProbability = 0.05;
        const maxTurnAngle = Math.PI / 4;

        // From paper and normalized to screen size
        // Amplitude is deviation from middle of screen
        const a_y = [0.2*height/2,0.2*height/2,0.2*height/2,0.15*height/2,0.11*height/2,0.08*height/2,0.06*height/2];
        const freq_y = [0.1,0.25,0.55,0.85,1.15,1.55,2.05];
         
        const a_x = [0.21*width/2,0.21*width/2,0.21*width/2,0.14*width/2,0.09*width/2,0.07*width/2,0.06*width/2];
        const freq_x = [0.15,0.35,0.65,0.95,1.45,1.85,2.15]

        let currentMousemoveHandler;

        let prevMouseX = null;
        let prevMouseY = null;
        let userDotX = width/2;
        let userDotY = height/2;
        let dist;

        let userPositions = [];
        let followPositions = [];
        let distances = [];
        let highlights = [];
        let phis = [];
        let animframe;
        let intervalId;

        function moveUser(e) {
            userDotX = e.clientX;
            userDotY = e.clientY;
            userDot.style.left = `${userDotX}px`;
            userDot.style.top = `${userDotY}px`;
        }

        function moveUserReverseXY(e) {
            
            userDotX -= e.movementX;
            userDotY -= e.movementY;
            userDot.style.left = `${userDotX}px`;
            userDot.style.top = `${userDotY}px`;
        }

        // CURRENTLY unused
        function moveUserOffsetRadians(e) {
            const radians = Math.PI / 4;

            if (prevMouseX === null || prevMouseY === null) {
                prevMouseX = e.clientX;
                prevMouseY = e.clientY;
                userDot.style.left = `${userDotX}px`;
                userDot.style.top = `${userDotY}px`;
                return; // Don't move on the first frame
            }

            const deltaX = e.clientX - prevMouseX;
            const deltaY = e.clientY - prevMouseY;

            // Rotate the delta
            const rotatedDeltaX = deltaX * Math.cos(radians) - deltaY * Math.sin(radians);
            const rotatedDeltaY = deltaX * Math.sin(radians) + deltaY * Math.cos(radians);

            userDotX += rotatedDeltaX;
            userDotY += rotatedDeltaY;

            userDotX = Math.max(0, Math.min(width, userDotX));
            userDotY = Math.max(0, Math.min(height, userDotY));

            userDot.style.left = `${userDotX}px`;
            userDot.style.top = `${userDotY}px`;

            prevMouseX = e.clientX;
            prevMouseY = e.clientY;
        }

        function distanceToDot(save){
            dist = Math.sqrt((userDotX - x) ** 2 + (userDotY - y) ** 2)
            return dist;
    
        }

        function calculateDistancePercentages() {
            const maxDistance = Math.max(...distances);
            const sectionSizes = {
                0: Math.round(1  * maxDistance / 15),
                1: Math.round(3  * maxDistance / 15),
                2: Math.round(7  * maxDistance / 15),
                3: Math.round(11 * maxDistance / 15),
                4: Math.round(15 * maxDistance / 15)
            };
            const sections = [0, 0, 0, 0, 0];

            distances.forEach(distance => {
                if (distance < sectionSizes[0]) {
                    sections[0]++;
                } else if (distance < sectionSizes[1]) {
                    sections[1]++;
                } else if (distance < sectionSizes[2]) {
                    sections[2]++;
                } else if (distance < sectionSizes[3]) {
                    sections[3]++;
                } else {
                    sections[4]++;
                }
            });

            const percentages = sections.map(count => (count / distances.length) * 100);
            console.log("Section Sizes:", sectionSizes);
            console.log("Distance Percentages:", percentages);
            return { sectionSizes, percentages };
        }

        function gen_phi(){
            const phi = [];
            for (let i = 0; i < 7; i++) {
                // Generate random number between -π and π
                const randomValue = (Math.random() * 2 * Math.PI) - Math.PI;
                phi.push(randomValue);
            }
            return phi;
        }

        function moveRandomDot(t, phi) {
            let dx = 0;
            for (let i = 0; i < 7; i++) {
                dx += a_x[i] * Math.cos(2 * Math.PI * t * freq_x[i] + phi[i]);
            }
            x = dx + width / 2;
            let dy = 0;
            for (let i = 0; i < 7; i++) {
                dy += a_y[i] * Math.cos(2 * Math.PI * t * freq_y[i] + phi[i]);
            }
            y = dy + height / 2;
            //console.log(x, y);

            /*
            if (Math.random() < turnProbability) {
                const turnAngle = (Math.random() * 2 - 1) * maxTurnAngle;
                const currentAngle = Math.atan2(vy, vx);
                const newAngle = currentAngle + turnAngle;
                const speed = speeds[Math.floor(Math.random() * speeds.length)];
                vx = Math.cos(newAngle) * speed;
                vy = Math.sin(newAngle) * speed;
            }

            x += vx;
            y += vy;
            let rando_minX = width / 8;
            let rando_maxX = width - rando_minX;
            let rando_minY = height / 12;
            let rando_maxY = height - rando_minY;
            if (x < rando_minX) { x = rando_minX; vx = -vx; } else if (x > rando_maxX) { x = rando_maxX; vx = -vx; }
            if (y < rando_minY) { y = rando_minY; vy = -vy; } else if (y > rando_maxY) { y = rando_maxY; vy = -vy; }
                */
            randomDot.style.left = `${x}px`;
            randomDot.style.top = `${y}px`;
        }

        function setMousemoveHandler() {
            if (currentMousemoveHandler) {
                document.removeEventListener('mousemove', currentMousemoveHandler);
            }

            if (game_type === "normal") {
                currentMousemoveHandler = moveUser;
            } else if (game_type === "reverse") {
                

                currentMousemoveHandler = moveUserReverseXY;
            } else if (game_type === "offset") {
                currentMousemoveHandler = moveUserOffsetRadians;
            }

            document.addEventListener('mousemove', currentMousemoveHandler);
        }

        async function uploadDotData(userPositions, followPositions, distances, phis) {
            try {
                console.log("Uploading user positions...");
        console.log("User Positions:", userPositions);
        console.log("Follow Positions:", followPositions);
        console.log("Distances:", distances);
        console.log("Phis:", phis);
        console.log("User ID:", auth.currentUser.uid);

                await setDoc(doc(db, "user_data", auth.currentUser.uid), {
                    positions: userPositions,
                    followPositions: followPositions,
                    distances: distances, 
                    phis_control: phis[0], // The random values used to generate the dot movement
                    phi_reverse: phis[1],
                    phi_post: phis[2],
                    uid: auth.currentUser.uid,
                    timestamp: Timestamp.fromDate(new Date())
                });
                console.log("User positions saved!");
            } catch (error) {
                console.error("Firestore write error:", error.message);
                console.error("Error details:", error);
            }
        }

        async function play(t, phi) {
            if (game_type === "done") {
                const { sectionSizes, percentages } = calculateDistancePercentages();
                localStorage.setItem('sectionSizes', JSON.stringify(Object.values(sectionSizes)));
                localStorage.setItem('percentages', JSON.stringify(percentages));
                localStorage.setItem('distances', JSON.stringify(distances));
                localStorage.setItem('game_timelegths', JSON.stringify(game_type_lengths));
                localStorage.setItem('highlights', JSON.stringify(highlights));
                if (do_upload){
                    await uploadDotData(userPositions, followPositions, distances, phis);
                }
                window.location.href = `done.html`;
                return;
            }
            moveRandomDot(t, phi);
            t = t+0.003;
            if (distanceToDot() < 100){
                userDot.style.backgroundColor = 'yellow';
            }
            else{
                userDot.style.backgroundColor = 'red';
            }
            animframe = requestAnimationFrame(()=> play(t, phi));
        }

        function recordPos(){
            intervalId = setInterval(() => {
                let time = Timestamp.now();
                userPositions.push({ x: userDotX, y: userDotY, game_mode: game_type, timestamp: time });
                followPositions.push({ x: x, y: y, game_mode: game_type, timestamp: time });
                distances.push(dist);
            }, 50);
            return intervalId;
        }
        function stopRecordPos(intervalId){
            clearInterval(intervalId)
        }

        function showCursor() {
            document.body.style.cursor = "auto"; // Ensure cursor is visible
        }
        
        function hideCursor() {
            document.body.style.cursor = "none"; // Hide cursor when the game resumes
        }
        function pauseGame(){
            // Center the dots
            userDotX = width/2;
            userDotY = height/2;
            x = width/2;
            y = height/2;
            userDot.style.left = `${userDotX}px`;
            userDot.style.top = `${userDotY}px`;
            randomDot.style.left = `${x}px`;
            randomDot.style.top = `${y}px`;

            cancelAnimationFrame(animframe);
            document.removeEventListener('mousemove', currentMousemoveHandler);
        }
        function resumeGame() {
            setMousemoveHandler();
            let phi = gen_phi();
            phis.push(phi);
            play(0, phi);
        }
        // Function to show the alert
        function showAlert(message, callback) {
            const modal = document.getElementById('customAlert');
            modal.querySelector("p").innerText = message; // Set custom message
            modal.style.display = 'flex';
            showCursor();

            // Ensure clicking "OK" closes the modal and resumes the game
            document.getElementById("okButton").onclick = function() {
                closeAlert();
                if (callback) callback(); // Run the next step only after closing
            };
        }

        // Function to close the alert and resume game
        function closeAlert() {
            document.getElementById('customAlert').style.display = 'none';
            hideCursor();
            resumeGame(); // Ensure the game resumes after closing
        }

        randomDot.style.left = `${x}px`;
        randomDot.style.top = `${y}px`;

        
        
        signInAnonymously(auth)
            .then(() => {
                console.log("User signed in anonymously");
                intervalId = recordPos();

                setMousemoveHandler();
                let phi = gen_phi();
                phis.push(phi);
                play(0, phi);
                
                // Very ugly nested setTimeouts. Might want to change later w/ recursion?
                setTimeout(() => { // Run when normal mode is over
                    pauseGame();
                    stopRecordPos(intervalId);
                    highlights.push(distances.length);
                    game_type = "reverse";
                    showAlert("Your controls have been switched! Try to adapt quickly. Click OK to continue.", () => {
                        intervalId = recordPos();
                        console.log("Game type changed to reverse");
        
                        setTimeout(() => { // Run when reverse mode is over
                            pauseGame();
                            stopRecordPos(intervalId);
                            highlights.push(distances.length);
                            game_type = "normal";
                            showAlert("Your controls have been switched again! Try to adapt quickly. Click OK to continue.", () => {
                                intervalId = recordPos();
                                console.log("Game type changed to normal");
        
                                setTimeout(() => { // Run when final normal mode is over
                                    stopRecordPos(intervalId)
                                    highlights.push(distances.length);
                                    // In the play loop, this variable change
                                    // cause sthe loop to end.
                                    game_type = "done"; 
                                }, game_type_lengths["normal"]);
                            });
                        }, game_type_lengths["reverse"]);
                    });
                }, game_type_lengths["normal"]);

            })
            .catch((error) => {
                console.error("Auth Error:", error.message);
            });
    </script>
</body>
</html>